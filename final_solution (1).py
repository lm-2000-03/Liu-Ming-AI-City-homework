# -*- coding: utf-8 -*-
"""Final Solution.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12PZQG3DMmjZozfWGw2PlBRrRuYQMGYVB
"""

!pip install blocksnet

import geopandas as gpd
import pandas as pd  # 添加 pandas 导入
import os
from shapely.geometry import shape
import json
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import random
import numpy as np
from blocksnet.preprocessing import BlocksGenerator
import seaborn as sns

# 读取 JSON 文件
input_file = "/content/未央区街道边界.json"  # 替换为您的 JSON 文件路径
output_file = "未央区街道边界.geojson"  # 输出的 GeoJSON 文件路径

with open(input_file, "r", encoding="utf-8") as f:
    data = json.load(f)

# 检查 JSON 结构是否符合 GeoJSON 要求
features = []
for street in data.get("features", []):  # 如果数据不是 GeoJSON 格式，请修改访问路径
    geometry = street.get("geometry")
    properties = street.get("properties", {})

    # 转换为 Shapely 几何对象并构造 Feature
    if geometry:
        features.append({
            "type": "Feature",
            "geometry": geometry,
            "properties": properties,
        })

# 构造 GeoJSON 对象
geojson_data = {
    "type": "FeatureCollection",
    "features": features,
}

# 保存为 GeoJSON 文件
with open(output_file, "w", encoding="utf-8") as f:
    json.dump(geojson_data, f, ensure_ascii=False, indent=4)

print(f"GeoJSON 文件已保存为: {output_file}")

# 使用 GeoPandas 读取生成的 GeoJSON
gdf = gpd.read_file("/content/未央区街道边界.geojson")

# 可视化
gdf.plot(edgecolor="blue", alpha=0.5)

# 定义投影坐标系（以 EPSG:3857 为例）
target_crs = "EPSG:3857"

# 检查并统一坐标系
geojson_files = [
    "道路网络.geojson",
    "公交地铁站.geojson",
    "公园.geojson",
    "河流.geojson",
    "商业区.geojson",
    "未央区街道边界.geojson",
    "学校.geojson",
    "医院.geojson"
]

for file in geojson_files:
    gdf = gpd.read_file(file)
    print(f"文件 {file} 的原始坐标系为：{gdf.crs}")

    # 转换为目标坐标系
    gdf = gdf.to_crs(target_crs)
    output_file = f"Reprojected_{file}"
    gdf.to_file(output_file, driver="GeoJSON")
    print(f"文件 {file} 已转换为目标坐标系，保存为：{output_file}")

# 加载街道边界
boundary = gpd.read_file("/content/Reprojected_未央区街道边界.geojson")

# 初始化 BlocksGenerator
generator = BlocksGenerator(boundaries=boundary)

# 执行区块划分
blocks = generator.run(min_block_width=10)  # 可调整 `min_block_width` 参数

# 可视化结果
fig, ax = plt.subplots(figsize=(12, 8))
boundaries.plot(ax=ax, edgecolor="black", label="Street Boundaries")
blocks.plot(ax=ax, color="lightblue", alpha=0.6, label="Generated Blocks")
ax.set_title("Divided Blocks Using BlocksNet", fontsize=16)
plt.legend()
plt.show()

# 为每个区块添加唯一ID
blocks["block_id"] = range(1, len(blocks) + 1)
print(blocks.head())

blocks.to_file("1.geojson", driver="GeoJSON")

# 导入每个设施的 GeoJSON 文件
public_transport = gpd.read_file("Reprojected_公交地铁站.geojson")
schools = gpd.read_file("Reprojected_学校.geojson")
commercial_areas = gpd.read_file("Reprojected_商业区.geojson")
hospitals = gpd.read_file("Reprojected_医院.geojson")
parks = gpd.read_file("Reprojected_公园.geojson")

# 查看每个文件的字段，确保关键信息存在
print("Public Transport Columns:", public_transport.columns)
print("Schools Columns:", schools.columns)
print("Commercial Areas Columns:", commercial_areas.columns)
print("Hospitals Columns:", hospitals.columns)
print("Parks Columns:", parks.columns)

# 确保所有数据与区块数据的坐标系一致
blocks_with_statistics = gpd.read_file("1.geojson")

# 统一坐标系为区块的坐标系
target_crs = blocks_with_statistics.crs
public_transport = public_transport.to_crs(target_crs)
schools = schools.to_crs(target_crs)
commercial_areas = commercial_areas.to_crs(target_crs)
hospitals = hospitals.to_crs(target_crs)
parks = parks.to_crs(target_crs)

# 使用空间关联，将每类设施分配到区块中
public_transport_in_blocks = gpd.sjoin(public_transport, blocks_with_statistics, how="left", predicate="intersects")
schools_in_blocks = gpd.sjoin(schools, blocks_with_statistics, how="left", predicate="intersects")
commercial_areas_in_blocks = gpd.sjoin(commercial_areas, blocks_with_statistics, how="left", predicate="intersects")
hospitals_in_blocks = gpd.sjoin(hospitals, blocks_with_statistics, how="left", predicate="intersects")
parks_in_blocks = gpd.sjoin(parks, blocks_with_statistics, how="left", predicate="intersects")

# 统计每个区块内的设施数量
public_transport_count = public_transport_in_blocks.groupby("block_id").size()
schools_count = schools_in_blocks.groupby("block_id").size()
commercial_areas_count = commercial_areas_in_blocks.groupby("block_id").size()
hospitals_count = hospitals_in_blocks.groupby("block_id").size()
parks_count = parks_in_blocks.groupby("block_id").size()

# 将统计结果合并到区块数据中
blocks_with_statistics["公共交通设施"] = blocks_with_statistics["block_id"].map(public_transport_count).fillna(0)
blocks_with_statistics["学校"] = blocks_with_statistics["block_id"].map(schools_count).fillna(0)
blocks_with_statistics["商业区"] = blocks_with_statistics["block_id"].map(commercial_areas_count).fillna(0)
blocks_with_statistics["医院"] = blocks_with_statistics["block_id"].map(hospitals_count).fillna(0)
blocks_with_statistics["公园"] = blocks_with_statistics["block_id"].map(parks_count).fillna(0)

# 检查结果
print(blocks_with_statistics.head())

# 保存结果为新的 GeoJSON 文件
blocks_with_statistics.to_file("2.geojson", driver="GeoJSON")

# 读取含有统计信息的 GeoJSON 文件
blocks_with_statistics = gpd.read_file("2.geojson")

# 检查数据是否成功加载
print("数据预览：")
print(blocks_with_statistics.head())

# 计算每个区块的所有设施总和
blocks_with_statistics["总设施数量"] = blocks_with_statistics[["公共交通设施", "学校", "商业区", "医院", "公园"]].sum(axis=1)

# 绘制所有设施总和的分布
fig, ax = plt.subplots(figsize=(12, 8))
blocks_with_statistics.plot(ax=ax, column="总设施数量", cmap="Blues", alpha=0.6, legend=True)
plt.title("Weiyang District Blocks with Total Facility Distribution", fontsize=16)
plt.show()

# 生成权重的模块化逻辑
def generate_weights():
    """
    定义基础设施的权重和区域权重。
    返回:
    - weights: dict，每种设施的基础权重。
    - region_weights: dict，每个区域的权重分配。
    """
    # 定义每种设施的基础权重
    weights = {
        '公共交通设施': 2.0,
        '学校': 1.5,
        '商业区': 1.2,
        '医院': 2.5,
        '公园': 1.0
    }

    # 定义每个区域的权重分配
    region_weights = {
        '西部': {'公共交通设施': 1.2, '学校': 1.0, '商业区': 1.1, '医院': 1.3, '公园': 1.2},
        '西北部': {'公共交通设施': 1.3, '学校': 1.1, '商业区': 1.0, '医院': 1.4, '公园': 1.1},
        '北部': {'公共交通设施': 1.0, '学校': 1.2, '商业区': 1.3, '医院': 1.0, '公园': 1.2},
        '东部': {'公共交通设施': 1.1, '学校': 1.3, '商业区': 1.2, '医院': 1.1, '公园': 1.3},
        '中部': {'公共交通设施': 1.5, '学校': 1.4, '商业区': 1.5, '医院': 1.3, '公园': 1.5}
    }

    return weights, region_weights

# 区域分配模块化
def assign_region(block_data):
    """
    根据区块中心位置分配区域。
    参数:
    - block_data: GeoDataFrame，包含区块信息。
    返回:
    - block_data: 添加了'region'列的GeoDataFrame。
    """
    def get_region(x, y):
        if x < block_data['geometry'].centroid.x.mean():  # 西部
            if y > block_data['geometry'].centroid.y.mean():
                return '西北部'
            else:
                return '西部'
        elif x > block_data['geometry'].centroid.x.mean():  # 东部
            if y > block_data['geometry'].centroid.y.mean():
                return '北部'
            else:
                return '东部'
        else:  # 中部
            return '中部'

    # 计算区块中心点
    block_data['centroid_x'] = block_data.geometry.centroid.x
    block_data['centroid_y'] = block_data.geometry.centroid.y

    # 分配区域
    block_data['region'] = block_data.apply(lambda row: get_region(row['centroid_x'], row['centroid_y']), axis=1)
    return block_data



# 2. 公共交通设施调整逻辑
def adjust_public_transport(block_data, max_total_increase=0.05, max_block_adjustment=0.05):
    """
    调整公共交通设施数量，确保总数限制和每个区块的变化限制。
    参数:
    - block_data: GeoDataFrame，包含区块信息。
    - max_total_increase: float，总公共交通设施数量的最大增长比例。
    - max_block_adjustment: float，单个区块的公共交通设施最大调整比例。
    返回:
    - adjusted_blocks: 调整后的GeoDataFrame。
    """
    adjusted_blocks = block_data.copy()
    total_transport = adjusted_blocks['公共交通设施'].sum()
    max_transport = total_transport * (1 + max_total_increase)

    for idx, row in adjusted_blocks.iterrows():
        current_transport = row['公共交通设施']
        adjustment = random.choice([-1, 1]) * int(current_transport * max_block_adjustment)
        new_transport = max(0, current_transport + adjustment)

        # 确保总数不超过限制
        if adjusted_blocks['公共交通设施'].sum() + (new_transport - current_transport) > max_transport:
            continue  # 跳过调整，避免超过总数限制

        adjusted_blocks.at[idx, '公共交通设施'] = new_transport

    return adjusted_blocks

# 3. 其他设施调整逻辑
def adjust_other_facilities(block_data, facility_columns, max_adjustment=0.1):
    """
    按照约束条件调整其他设施数量。
    参数:
    - block_data: GeoDataFrame，包含区块信息。
    - facility_columns: list，需要调整的设施列名。
    - max_adjustment: float，每类设施数量的最大调整比例。
    返回:
    - adjusted_blocks: 调整后的GeoDataFrame。
    """
    adjusted_blocks = block_data.copy()

    for idx, row in adjusted_blocks.iterrows():
        total_facilities = row[facility_columns].sum()
        for facility in facility_columns:
            adjustment = random.choice([-1, 1]) * int(row[facility] * max_adjustment)
            adjusted_blocks.at[idx, facility] = max(0, row[facility] + adjustment)

        # 确保总设施数量不变
        diff = total_facilities - adjusted_blocks.loc[idx, facility_columns].sum()
        if diff != 0:
            adjusted_blocks.at[idx, facility_columns[0]] += diff  # 平衡差值到第一个设施

    return adjusted_blocks

# 4. 分数计算逻辑
def calculate_block_score_with(row, facility_columns, area_column, weights, region_weights, epsilon=0.01, max_score_per_facility=100):
    """
    计算单个区块的得分，包含小面积修正。
    参数:
    - row: DataFrame 行，表示一个区块的信息。
    - facility_columns: list，设施列名。
    - area_column: str，表示面积的列名。
    - weights: dict，每种设施的基础权重。
    - region_weights: dict，每个区域的权重分配。
    - epsilon: float，小面积修正参数，避免爆炸性密度。
    - max_score_per_facility: float，每种设施的最大得分。
    返回:
    - block_score: float，单个区块的得分。
    """
    block_score = 0
    for facility in facility_columns:
        base_weight = weights.get(facility, 1.0)
        region_weight = region_weights.get(row['region'], {}).get(facility, 1.0)

        # 修正密度，避免小面积导致异常值
        facility_density = row[facility] / (row[area_column] + epsilon)

        # 限制单种设施的最大得分
        facility_score = min(facility_density * 10 * base_weight * region_weight, max_score_per_facility)
        block_score += facility_score

    # 特殊处理区块 id 5 和 10
    if row['block_id'] in [5, 10]:
        block_score /= 100  # 将得分除以 100

    return block_score

def calculate_total_score(block_data, facility_columns, area_column, weights, region_weights):
    """
    计算所有区块的总得分，包含修正逻辑。
    """
    block_data['block_score'] = block_data.apply(
        calculate_block_score_with,
        axis=1,
        facility_columns=facility_columns,
        area_column=area_column,
        weights=weights,
        region_weights=region_weights
    )
    total_score = block_data['block_score'].sum()
    return total_score, block_data

# 5. 可视化初始状态
def visualize_initial_state(gdf, score_column='block_score', region_column='region', cmap='Blues'):
    """
    可视化区块的初始状态，包括得分分布和区域分类。
    """
    import matplotlib.pyplot as plt

    # 确保 score_column 数据完整
    if gdf[score_column].isnull().any():
        print(f"警告：{score_column} 列存在 NaN 值，已填充为 0")
        gdf[score_column] = gdf[score_column].fillna(0)

    if gdf[score_column].dtype != 'float64' and gdf[score_column].dtype != 'int64':
        print(f"警告：{score_column} 列数据类型异常，尝试转换为 float 类型")
        gdf[score_column] = gdf[score_column].astype(float)

    fig, axes = plt.subplots(1, 2, figsize=(16, 8))

    # 绘制得分分布
    gdf.plot(column=score_column, cmap=cmap, legend=True, ax=axes[0], edgecolor='black',
             vmin=gdf[score_column].min(), vmax=gdf[score_column].max())
    axes[0].set_title('Block Score Distribution', fontsize=16)
    axes[0].set_axis_off()
    for idx, row in gdf.iterrows():
        centroid = row['geometry'].centroid
        axes[0].text(centroid.x, centroid.y, str(row['block_id']),
                     fontsize=8, color='black', ha='center', va='center')

    # 绘制区域分布
    gdf.plot(column=region_column, cmap='tab20', legend=True, ax=axes[1], edgecolor='black')
    axes[1].set_title('Block Region Distribution', fontsize=16)
    axes[1].set_axis_off()
    for idx, row in gdf.iterrows():
        centroid = row['geometry'].centroid
        axes[1].text(centroid.x, centroid.y, str(row['block_id']),
                     fontsize=8, color='black', ha='center', va='center')

    plt.tight_layout()
    plt.show()

# 主程序
# 加载 2.geojson 文件
file_path = "2.geojson"
blocks_with_statistics = gpd.read_file(file_path)

# 调用区域分配函数
blocks_with_statistics = assign_region(blocks_with_statistics)

# 调用权重生成模块
weights, region_weights = generate_weights()

# 定义设施列
facility_columns = ['公共交通设施', '学校', '商业区', '医院', '公园']

# 计算面积
blocks_with_statistics['area'] = blocks_with_statistics.geometry.area / 1e6  # 转换为平方千米

# 计算初始得分
total_score, blocks_with_statistics = calculate_total_score(
    blocks_with_statistics,
    facility_columns=facility_columns,
    area_column='area',
    weights=weights,
    region_weights=region_weights
)

# 调用可视化函数，绘制初始状态
visualize_initial_state(
    blocks_with_statistics,
    score_column='block_score',  # 列名对应得分
    region_column='region'      # 列名对应区域分类
)

# 按照输出格式打印结果
print("每个区块的区域和得分：")
print(blocks_with_statistics[['block_id', 'region', 'block_score']])

print("\n总得分:", total_score)

print("\n设施数量统计：")
print("=" * 50)
total_facilities = blocks_with_statistics[facility_columns].sum()
print("各类型设施的总数量:")
print(total_facilities)

print("\n每个区块的设施数量:")
print(blocks_with_statistics[['block_id'] + facility_columns])

# 设置随机数种子
random.seed(50)
np.random.seed(50)

def simulated_annealing(block_data, facility_columns, area_column, weights, region_weights,
                        max_iter=1000, t_max=100, t_min=1e-3, cooling_rate=0.95):
    """
    模拟退火算法优化区块内设施分布，以最大化总得分。
    参数:
    - block_data: GeoDataFrame，区块数据。
    - facility_columns: list，设施列名。
    - area_column: str，表示面积的列名。
    - weights: dict，每种设施的基础权重。
    - region_weights: dict，每个区域的权重分配。
    - max_iter: int，最大迭代次数。
    - t_max: float，初始温度。
    - t_min: float，最低温度。
    - cooling_rate: float，温度衰减率。
    返回:
    - best_solution: GeoDataFrame，最优解。
    - best_score: float，最优得分。
    """
    import numpy as np
    import random

    # 初始解：当前设施分布
    current_solution = block_data.copy()
    _, current_solution = calculate_total_score(
        current_solution, facility_columns, area_column, weights, region_weights
    )
    current_score = current_solution['block_score'].sum()

    # 初始化最优解
    best_solution = current_solution.copy()
    best_score = current_score

    # 初始温度
    temperature = t_max

    for iteration in range(max_iter):
        # 生成新解
        new_solution = current_solution.copy()
        block_idx = random.choice(new_solution.index)
        facility = random.choice(facility_columns)

        # 随机调整设施数量（约束 ±10%）
        adjustment = random.choice([-1, 1]) * int(0.1 * new_solution.loc[block_idx, facility])
        new_solution.loc[block_idx, facility] = max(0, new_solution.loc[block_idx, facility] + adjustment)

        # 添加公共交通设施约束
        total_transport = new_solution['公共交通设施'].sum()
        max_transport = block_data['公共交通设施'].sum() * 1.05
        if total_transport > max_transport:
            continue

        # 计算新解的得分
        _, new_solution = calculate_total_score(
            new_solution, facility_columns, area_column, weights, region_weights
        )
        new_score = new_solution['block_score'].sum()

        # 计算接受概率
        delta = new_score - current_score
        acceptance_probability = np.exp(delta / temperature) if delta < 0 else 1.0

        # 接受新解
        if random.random() < acceptance_probability:
            current_solution = new_solution
            current_score = new_score

            # 更新最优解
            if new_score > best_score:
                best_solution = new_solution
                best_score = new_score

        # 温度衰减
        temperature *= cooling_rate
        if temperature < t_min:
            break

    return best_solution, best_score

# 调用模拟退火算法
optimized_result, optimized_score = simulated_annealing(
    block_data=blocks_with_statistics,
    facility_columns=['公共交通设施', '学校', '商业区', '医院', '公园'],
    area_column='area',
    weights=weights,
    region_weights=region_weights,
    max_iter=500,
    t_max=100,
    t_min=1e-3,
    cooling_rate=0.95
)

# 按格式输出优化结果
print("优化后的每个区块的区域和得分：")
print(optimized_result[['block_id', 'region', 'block_score']])

print("\n优化后的总得分:", optimized_score)

print("\n优化后设施数量统计：")
print("=" * 50)
optimized_facilities = optimized_result[facility_columns].sum()
print("各类型设施的总数量:")
print(optimized_facilities)

print("\n优化后每个区块的设施数量:")
print(optimized_result[['block_id'] + facility_columns])

# 调用可视化函数，显示优化后的状态
visualize_initial_state(
    optimized_result,
    score_column='block_score',  # 列名对应得分
    region_column='region'      # 列名对应区域分类
)

# 保存结果
optimized_result.to_csv("optimized_simulated_annealing_result.csv", index=False, encoding='utf-8')
print("优化后的退火算法结果已保存为 optimized_simulated_annealing_result.csv")

# 设置随机数种子
random.seed(50)
np.random.seed(50)

# 遗传算法参数
POPULATION_SIZE = 50  # 种群大小
GENERATIONS = 100     # 迭代次数
MUTATION_RATE = 0.1   # 变异概率

# 初始化种群
def initialize_population(block_data, facility_columns):
    population = []
    max_transport = block_data['公共交通设施'].sum() * 1.05

    for _ in range(POPULATION_SIZE):
        individual = block_data.copy()
        for facility in facility_columns:
            individual[facility] = individual[facility].apply(
                lambda x: int(x * (1 + random.uniform(-0.1, 0.1)))
            ).clip(1, None).astype(int)  # 确保数据类型为 int

        # 检查公共交通设施总量是否超出约束
        while individual['公共交通设施'].sum() > max_transport:
            adjustment_idx = random.choice(individual.index)
            individual.loc[adjustment_idx, '公共交通设施'] = max(
                individual.loc[adjustment_idx, '公共交通设施'] - 1, 0
            )
        population.append(individual)
    return population

# 适应度函数
def fitness(individual, block_data, facility_columns, area_column, weights, region_weights, penalty_weight=100):
    """
    计算个体适应度。
    - individual: 个体数据。
    - block_data: 原始区块数据。
    - facility_columns: 设施列名。
    - area_column: 面积列名。
    - weights: 权重字典。
    - region_weights: 区域权重字典。
    - penalty_weight: 违反约束条件的惩罚权重。
    """
    total_score, scored_data = calculate_total_score(
        individual, facility_columns, area_column, weights, region_weights
    )

    # 添加约束惩罚
    total_transport = individual['公共交通设施'].sum()
    max_transport = block_data['公共交通设施'].sum() * 1.05
    if total_transport > max_transport:
        penalty = (total_transport - max_transport) * penalty_weight
        total_score -= penalty

    return total_score


# 选择父代
def select_parents(population, fitness_scores):
    adjusted_scores = [max(score, 1e-6) for score in fitness_scores]  # 避免分数为零
    return random.choices(population, weights=adjusted_scores, k=POPULATION_SIZE)

# 交叉操作
def crossover(parent1, parent2, facility_columns):
    child = parent1.copy()
    for facility in facility_columns:
        # 从父代平均组合设施数量
        child[facility] = ((parent1[facility] + parent2[facility]) / 2).astype(int)
    return child

# 变异操作
def mutate(individual, facility_columns):
    for facility in facility_columns:
        if random.random() < MUTATION_RATE:
            adjustment = int(individual[facility].mean() * 0.1)  # 变异 ±10%
            individual[facility] = (individual[facility] + random.choice([-adjustment, adjustment])).clip(1, None)
    return individual

## 遗传算法主函数
def genetic_algorithm(block_data, facility_columns, area_column, weights, region_weights):
    # 初始化种群
    population = initialize_population(block_data, facility_columns)

    # 遗传算法迭代
    best_solution = None
    best_score = -np.inf

    for generation in range(GENERATIONS):
        # 计算适应度
        fitness_scores = [
            fitness(ind, block_data, facility_columns, area_column, weights, region_weights) for ind in population
        ]
        current_best_score = max(fitness_scores)
        print(f"Generation {generation+1}: Best Score = {current_best_score}")

        if current_best_score > best_score:
            best_score = current_best_score
            best_solution = population[fitness_scores.index(current_best_score)]

        # 选择父代
        parents = select_parents(population, fitness_scores)
        next_generation = []

        # 交叉和变异
        for i in range(0, POPULATION_SIZE, 2):
            child1 = crossover(parents[i], parents[i+1], facility_columns)
            child2 = crossover(parents[i+1], parents[i], facility_columns)
            next_generation.append(mutate(child1, facility_columns))
            next_generation.append(mutate(child2, facility_columns))

        population = next_generation

    # 最优解得分计算
    total_score, best_solution = calculate_total_score(
        best_solution, facility_columns, area_column, weights, region_weights
    )

    return best_solution, total_score

# 调用遗传算法并输出结果
best_solution, best_score = genetic_algorithm(
    block_data=blocks_with_statistics,
    facility_columns=facility_columns,
    area_column='area',
    weights=weights,
    region_weights=region_weights
)

# 按格式输出优化结果
print("优化后的每个区块的区域和得分：")
print(best_solution[['block_id', 'region', 'block_score']])

print("\n优化后的总得分:", best_score)

print("\n优化后每个区块的设施数量：")
print(best_solution[['block_id'] + facility_columns])

# 调用可视化函数，显示优化后的状态
visualize_initial_state(
    optimized_result,
    score_column='block_score',  # 列名对应得分
    region_column='region'      # 列名对应区域分类
)

# 保存结果为 CSV 文件
best_solution.to_csv("genetic_algorithm_result.csv", index=False, encoding='utf-8')  # 使用 best_solution
print("遗传算法优化结果已保存为 genetic_algorithm_result.csv")

# 删除 SimHei 字体设置
from matplotlib import rcParams

# 恢复默认字体
rcParams['font.sans-serif'] = ['DejaVu Sans']  # 使用 Matplotlib 默认字体
rcParams['axes.unicode_minus'] = False  # 正常显示负号


# 文件路径
file1 = "genetic_algorithm_result.csv"
file2 = "optimized_simulated_annealing_result.csv"
geojson_file = "2.geojson"  # 使用 2.geojson 进行可视化

# 读取两个文件
df1 = pd.read_csv(file1, encoding='utf-8')
df2 = pd.read_csv(file2, encoding='utf-8')

# 添加来源列以标识算法类型
df1['source'] = 'genetic_algorithm'
df2['source'] = 'simulated_annealing'

# 将中文列名替换为英文列名
df1 = df1.rename(columns={
    '公共交通设施': 'public_transport',
    '学校': 'school',
    '商业区': 'commercial_area',
    '医院': 'hospital',
    '公园': 'park'
})
df2 = df2.rename(columns={
    '公共交通设施': 'public_transport',
    '学校': 'school',
    '商业区': 'commercial_area',
    '医院': 'hospital',
    '公园': 'park'
})

# 合并数据
merged_df = pd.merge(df1, df2, on="block_id", suffixes=('_ga', '_sa'), how="outer")

# 计算得分和设施数量的不同
columns_to_compare = ['block_score', 'public_transport', 'school', 'commercial_area', 'hospital', 'park']
for col in columns_to_compare:
    merged_df[f"{col}_difference"] = merged_df[f"{col}_ga"] - merged_df[f"{col}_sa"]

# 总设施差值
merged_df['total_facility_difference'] = merged_df[
    [f"{col}_difference" for col in ['public_transport', 'school', 'commercial_area', 'hospital', 'park']]
].sum(axis=1)

# 展示差值数据表格
print("Difference Data Table:")
print(merged_df[['block_id'] + [f"{col}_difference" for col in columns_to_compare] + ['total_facility_difference']].to_string())

# 可视化差值（负值为蓝，正值为红）
for col in columns_to_compare:
    plt.figure(figsize=(10, 6))
    sns.barplot(x='block_id', y=f"{col}_difference", data=merged_df, palette='coolwarm', edgecolor='black')
    plt.title(f"Difference in {col}: Genetic Algorithm - Simulated Annealing", fontsize=16)
    plt.xlabel("Block ID", fontsize=14)
    plt.ylabel(f"{col} Difference", fontsize=14)
    plt.xticks(rotation=45)
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.show()

# 地图可视化差值
try:
    # 读取 2.geojson 文件
    gdf = gpd.read_file(geojson_file)

    # 合并 GeoDataFrame 和差值数据
    gdf = gdf.merge(merged_df, on="block_id")

    # 绘制地图
    plt.figure(figsize=(12, 8))
    gdf.plot(
        column='total_facility_difference',
        cmap='coolwarm',
        legend=True,
        edgecolor='black'
    )
    plt.title("Total Facility Difference: Genetic Algorithm - Simulated Annealing", fontsize=16)
    plt.show()
except Exception as e:
    print("Map visualization failed. Please check the 2.geojson file path or data format.", e)